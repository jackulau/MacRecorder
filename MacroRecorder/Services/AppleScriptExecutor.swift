//
//  AppleScriptExecutor.swift
//  MacroRecorder
//
//  Service for executing AppleScript and generating scripts from macros
//

import Foundation
import Carbon

class AppleScriptExecutor: ObservableObject {
    static let shared = AppleScriptExecutor()

    @Published var lastError: String?
    @Published var isExecuting = false

    private init() {}

    // MARK: - Execution

    /// Execute inline AppleScript code
    func execute(script: String, timeout: TimeInterval = 30) async throws -> String? {
        return try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                DispatchQueue.main.async { self.isExecuting = true }
                defer { DispatchQueue.main.async { self.isExecuting = false } }

                var error: NSDictionary?
                let appleScript = NSAppleScript(source: script)

                guard let script = appleScript else {
                    continuation.resume(throwing: AppleScriptError.invalidScript("Failed to create AppleScript"))
                    return
                }

                let result = script.executeAndReturnError(&error)

                if let error = error {
                    let errorMessage = error[NSAppleScript.errorMessage] as? String ?? "Unknown error"
                    DispatchQueue.main.async { self.lastError = errorMessage }
                    continuation.resume(throwing: AppleScriptError.executionFailed(errorMessage))
                    return
                }

                let output = result.stringValue
                DispatchQueue.main.async { self.lastError = nil }
                continuation.resume(returning: output)
            }
        }
    }

    /// Execute script from a file path
    func executeFile(at path: String, timeout: TimeInterval = 30) async throws -> String? {
        guard FileManager.default.fileExists(atPath: path) else {
            throw AppleScriptError.fileNotFound(path)
        }

        let scriptContent = try String(contentsOfFile: path, encoding: .utf8)
        return try await execute(script: scriptContent, timeout: timeout)
    }

    // MARK: - Validation

    /// Validate AppleScript syntax without executing
    func validate(script: String) -> (valid: Bool, error: String?) {
        var error: NSDictionary?
        let appleScript = NSAppleScript(source: script)

        guard let script = appleScript else {
            return (false, "Failed to create AppleScript")
        }

        _ = script.compileAndReturnError(&error)

        if let error = error {
            let errorMessage = error[NSAppleScript.errorMessage] as? String ?? "Unknown error"
            return (false, errorMessage)
        }

        return (true, nil)
    }

    // MARK: - Script Generation

    /// Generate AppleScript from a macro
    func generateScript(from macro: Macro) -> String {
        var lines: [String] = []

        lines.append("-- Generated by MacroRecorder")
        lines.append("-- Macro: \(macro.name)")
        lines.append("-- Events: \(macro.events.count)")
        lines.append("")
        lines.append("tell application \"System Events\"")

        for event in macro.events {
            // Add delay if needed
            if event.delay > 0.01 {
                lines.append("    delay \(String(format: "%.3f", event.delay))")
            }

            // Generate event code
            switch event.type {
            case .mouseLeftDown, .mouseLeftUp:
                if let pos = event.position {
                    if event.type == .mouseLeftDown {
                        lines.append("    -- Click at position (\(Int(pos.x)), \(Int(pos.y)))")
                        lines.append("    click at {\(Int(pos.x)), \(Int(pos.y))}")
                    }
                }

            case .mouseRightDown, .mouseRightUp:
                if let pos = event.position {
                    if event.type == .mouseRightDown {
                        lines.append("    -- Right-click at position (\(Int(pos.x)), \(Int(pos.y)))")
                    }
                }

            case .mouseMove:
                // Mouse moves are typically not scripted in AppleScript
                break

            case .mouseDrag:
                if let pos = event.position {
                    lines.append("    -- Drag to position (\(Int(pos.x)), \(Int(pos.y)))")
                }

            case .keyDown:
                if let keyCode = event.keyCode {
                    let keyString = keyCodeToAppleScript(keyCode: keyCode, flags: event.flags ?? 0)
                    lines.append("    \(keyString)")
                }

            case .keyUp:
                // Key up events are typically implicit in AppleScript
                break

            case .scroll:
                if let deltaY = event.scrollDeltaY, deltaY != 0 {
                    let direction = deltaY > 0 ? "up" : "down"
                    lines.append("    -- Scroll \(direction)")
                }

            case .windowFocus:
                if let bundleId = event.windowInfo?.bundleIdentifier {
                    lines.append("    tell application id \"\(bundleId)\" to activate")
                }

            case .appleScript:
                if let script = event.scriptContent {
                    lines.append("    -- Inline AppleScript")
                    lines.append("    \(script)")
                }

            case .appleScriptFile:
                if let path = event.scriptPath {
                    lines.append("    -- Run script from file: \(path)")
                }

            case .conditionStart, .conditionElse, .conditionEnd,
                 .loopStart, .loopEnd, .breakLoop, .continueLoop:
                lines.append("    -- Control flow: \(event.type.displayName)")

            case .clickImage, .waitForImage, .dragToImage:
                lines.append("    -- Image-based event: \(event.type.displayName)")
            }
        }

        lines.append("end tell")

        return lines.joined(separator: "\n")
    }

    /// Export macro to AppleScript file
    func exportToFile(macro: Macro, at url: URL) throws {
        let script = generateScript(from: macro)
        try script.write(to: url, atomically: true, encoding: .utf8)
    }

    // MARK: - Helpers

    private func keyCodeToAppleScript(keyCode: UInt16, flags: UInt64) -> String {
        let keyNames: [UInt16: String] = [
            0x00: "a", 0x01: "s", 0x02: "d", 0x03: "f", 0x04: "h", 0x05: "g",
            0x06: "z", 0x07: "x", 0x08: "c", 0x09: "v", 0x0B: "b", 0x0C: "q",
            0x0D: "w", 0x0E: "e", 0x0F: "r", 0x10: "y", 0x11: "t",
            0x24: "return", 0x30: "tab", 0x31: "space", 0x33: "delete", 0x35: "escape",
            0x7B: "left arrow", 0x7C: "right arrow", 0x7D: "down arrow", 0x7E: "up arrow"
        ]

        var modifiers: [String] = []
        let cgFlags = CGEventFlags(rawValue: flags)

        if cgFlags.contains(.maskCommand) { modifiers.append("command down") }
        if cgFlags.contains(.maskShift) { modifiers.append("shift down") }
        if cgFlags.contains(.maskAlternate) { modifiers.append("option down") }
        if cgFlags.contains(.maskControl) { modifiers.append("control down") }

        let keyName = keyNames[keyCode] ?? String(format: "key code %d", keyCode)

        if modifiers.isEmpty {
            if keyName.count == 1 {
                return "keystroke \"\(keyName)\""
            } else {
                return "key code \(keyCode)"
            }
        } else {
            let modifierString = modifiers.joined(separator: ", ")
            if keyName.count == 1 {
                return "keystroke \"\(keyName)\" using {\(modifierString)}"
            } else {
                return "key code \(keyCode) using {\(modifierString)}"
            }
        }
    }
}

// MARK: - Error Types

enum AppleScriptError: LocalizedError {
    case invalidScript(String)
    case executionFailed(String)
    case fileNotFound(String)
    case timeout

    var errorDescription: String? {
        switch self {
        case .invalidScript(let message): return "Invalid script: \(message)"
        case .executionFailed(let message): return "Execution failed: \(message)"
        case .fileNotFound(let path): return "Script file not found: \(path)"
        case .timeout: return "Script execution timed out"
        }
    }
}
